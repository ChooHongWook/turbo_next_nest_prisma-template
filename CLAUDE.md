# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Turborepo-based monorepo with Next.js 15 frontend, NestJS 11 backend, and Prisma ORM for type-safe fullstack development.

## Essential Commands

### Development

```bash
pnpm run dev          # Start both FE (3001) and BE (3000) in watch mode
pnpm run build        # Build all apps/packages in dependency order
pnpm run start        # Start production builds
```

### Database Operations

```bash
docker-compose up -d             # Start PostgreSQL (required first)
pnpm run db:migrate:dev          # Create and apply migrations (runs in packages/database)
pnpm run db:push                 # Push schema changes without migrations
pnpm run db:generate             # Regenerate Prisma Client after schema changes
pnpm run db:seed                 # Seed database with initial data
pnpm run db:studio               # Open Prisma Studio GUI (port 5555)
```

**Important**: `db:migrate:dev` runs directly in `packages/database` (not via Turbo) to avoid interactive mode restrictions.

### Testing & Code Quality

```bash
pnpm run test                    # Run all tests via Turbo
pnpm run lint                    # ESLint across all packages
pnpm run format                  # Prettier format all files
cd apps/be && pnpm run test:watch    # Watch mode for backend tests
```

### Environment Variables

```bash
pnpm run sync:env     # Sync .env.shared to all apps/packages (auto-runs in predev/prebuild)
```

## Architecture

### Monorepo Structure

```
apps/
  be/          # NestJS backend (port 3000)
  fe/          # Next.js frontend (port 3001)
packages/
  @repo/api              # Shared DTOs and entities
  @repo/database         # Prisma schema and client
  @repo/eslint-config    # Shared ESLint config
  @repo/typescript-config # Shared TypeScript config
  @repo/jest-config      # Shared Jest config
  @repo/ui               # Shared React components
```

### Critical: Three-Layer Type System

The core architectural pattern ensuring type safety across the stack:

1. **Prisma Schema** (`packages/database/prisma/schema.prisma`) - Single source of truth
2. **Generated Client** (`packages/database/generated/client`) - Auto-generated by Prisma
3. **API Entities** (`packages/api/src/*/entities/*.entity.ts`) - Implement Prisma types, exported for consumption

Example flow:

- Define `User` in Prisma schema
- Run `pnpm run db:generate` to generate types
- Create `User` entity in `@repo/api` implementing Prisma's `User` type
- Export from `packages/api/src/entry.ts`
- Both apps import type-safe `User` from `@repo/api`

### Hybrid Data Fetching Pattern (Next.js)

**Two distinct approaches depending on component type:**

1. **Server Components → Prisma Direct Access**

```typescript
// apps/fe/app/page.tsx
import { prisma } from '@repo/database/client';

export default async function Home() {
  const users = await prisma.user.findMany(); // Direct DB access in RSC
}
```

2. **Client Components → REST API**

```typescript
// apps/fe/src/api/links/index.ts
import { api } from '@config/axios';
export async function getLinks() {
  const res = await api.get<Link[]>('/links'); // Backend API call
}
```

**When to use each:**

- Server Components: Use Prisma directly for SSR (no API roundtrip needed)
- Client Components: Use REST API for mutations and client-side fetching
- Both share types from `@repo/api` for type safety

### Environment Management

**CRITICAL**: Uses `.env.shared` at root with auto-sync mechanism:

- Edit `.env.shared` (created from `.env.shared.example` if missing)
- Run `pnpm sync:env` (or it auto-runs via predev/prebuild hooks)
- `scripts/sync-env.js` copies to `apps/*/.env` and `packages/*/.env`

Never edit individual `.env` files in apps/packages directly.

### Package Imports

All internal packages use `@repo/*` scope:

```typescript
// Backend
import { CreateUserDto, User } from '@repo/api';
import { PrismaClient } from '@repo/database/client';

// Frontend
import { User } from '@repo/api';
import { Button } from '@repo/ui';
```

Frontend also uses path aliases (`@api/*`, `@config/*`, `@provider`) defined in `apps/fe/tsconfig.json`.

## Key Development Patterns

### TypeScript Type Safety

**CRITICAL**: Never use `any` type in this codebase. Always use proper TypeScript types.

**Guidelines:**

- Use explicit types from Prisma schema or `@repo/api`
- Use `unknown` instead of `any` when type is truly unknown
- Use generic types or utility types (`Partial`, `Pick`, `Omit`, etc.)
- Use type inference when TypeScript can determine the type
- Create custom types/interfaces when needed

**Examples:**

```typescript
// ❌ BAD - Using any
function processData(data: any) {
  return data;
}

// ✅ GOOD - Using proper types
import { User } from '@repo/api';
function processUser(user: User) {
  return user;
}

// ✅ GOOD - Using unknown for truly unknown types
function parseJson(json: string): unknown {
  return JSON.parse(json);
}

// ✅ GOOD - Using generics
function getData<T>(id: string): Promise<T> {
  return api.get<T>(`/data/${id}`);
}
```

### Adding a New Entity

1. Update `packages/database/prisma/schema.prisma`
2. Run `pnpm run db:migrate:dev` (creates migration + generates client)
3. Create DTOs in `packages/api/src/<entity>/dto/`
4. Create entity class implementing Prisma type in `packages/api/src/<entity>/entities/`
5. Export from `packages/api/src/entry.ts`
6. Create NestJS module/service/controller in `apps/be/src/<entity>/`
7. Use types from `@repo/api` in both apps

### NestJS Prisma Integration

- Custom `PrismaService` in `apps/be/src/prisma/` extends `PrismaClient`
- Implements `OnModuleInit` for connection lifecycle
- Logs queries in development via `$on('query')`
- Each module imports `PrismaModule` to inject `PrismaService`

### DTO Pattern

Uses `@nestjs/mapped-types` for inheritance:

```typescript
export class UpdateUserDto extends PartialType(CreateUserDto) {}
```

### Database Seeding

Uses `upsert` for idempotency:

```typescript
await prisma.user.upsert({
  where: { email: user.email },
  update: { ...user },
  create: { ...user },
});
```

Safe to run multiple times without duplicates.

### React Query Configuration

Server/client-aware QueryClient pattern in `apps/fe/src/config/get-query-client.ts`:

- Server: New instance per request
- Browser: Singleton instance
- Defaults: `staleTime: 60000ms`, query dehydration enabled

### Turbo Task Dependencies

From `turbo.json`:

- `build` depends on `^build` (builds dependencies first)
- `dev` has `persistent: true` and `cache: false`
- Database tasks (`db:*`) have `cache: false` (prevent stale state)
- `predev`/`prebuild` run `sync:env` and `db:generate`

## Service Ports

- Frontend: http://localhost:3001
- Backend: http://localhost:3000
- PostgreSQL: localhost:5432
- Prisma Studio: http://localhost:5555

## UI Components

### shadcn/ui Integration

**CRITICAL**: This project uses **shadcn/ui** for all UI components. Always use shadcn/ui components instead of creating custom ones.

**Setup:**

- Components are located in `apps/fe/components/ui/`
- Configuration: `apps/fe/components.json`
- Styling: Tailwind CSS v3 with CSS variables
- Utility function: `cn()` in `apps/fe/lib/utils.ts`

**Adding new components:**

```bash
npx shadcn@latest add <component-name>
```

**Usage example:**

```typescript
import { Button } from "@/components/ui/button";

export default function Page() {
  return <Button variant="default">Click me</Button>;
}
```

**Available shadcn MCP:**
The project has shadcn MCP configured in `.mcp.json` for AI-assisted component management.

**Styling guidelines:**

- Use Tailwind utility classes
- Use `cn()` utility for conditional classes
- Follow shadcn's variant patterns for customization
- Dark mode is supported via CSS variables (`.dark` class)

## Tech Stack Versions

- Node.js: >=22.19.0
- pnpm: 10.15.1
- Turborepo: 2.5.8
- Next.js: 15.x (with Turbopack)
- NestJS: 11.x
- React: 19.x
- Prisma: 6.19.0
- TypeScript: 5.5.4
- Tailwind CSS: 3.4.x
- shadcn/ui: latest

## Important Files

- `turbo.json` - Task orchestration and caching
- `pnpm-workspace.yaml` - Workspace structure
- `scripts/sync-env.js` - Environment sync logic
- `packages/database/prisma/schema.prisma` - Database schema
- `apps/be/src/prisma/prisma.service.ts` - Prisma integration
- `packages/api/src/entry.ts` - Centralized API exports
- `.github/copilot-instructions.md` - Detailed architectural patterns
