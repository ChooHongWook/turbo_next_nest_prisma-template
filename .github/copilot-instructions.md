# Turborepo Fullstack Project - AI Coding Agent Instructions

## Architecture Overview

This is a **pnpm workspace + Turborepo monorepo** with a clear separation between frontend (Next.js), backend (NestJS), and shared packages. The key architectural decision is using internal packages for **type-safe sharing** between apps.

### Core Components

- **apps/be**: NestJS backend (port 3000) using `@repo/api` for DTOs/entities and `@repo/database` for Prisma access
- **apps/fe**: Next.js frontend (port 3001) consuming types from `@repo/api`
- **packages/database**: Single source of truth for Prisma schema, generates client to `generated/client/`
- **packages/api**: Shared DTOs and entities that implement Prisma types, consumed by both BE and FE
- **packages/{eslint-config,typescript-config,jest-config,ui}**: Shared configuration and components

### Critical Architectural Pattern: Three-Layer Type System

1. **Prisma Schema** (`packages/database/prisma/schema.prisma`) - Database schema
2. **Generated Client** (`packages/database/generated/client`) - Auto-generated by Prisma
3. **API Entities** (`packages/api/src/*/entities/*.entity.ts`) - Implement Prisma types, exported for app consumption

Example: `User` entity in `@repo/api` implements `User` from `@repo/database/client`, ensuring type safety across the stack.

## Essential Workflows

### Environment Management

**CRITICAL**: This project uses `.env.shared` at the root with auto-sync to all apps/packages:

```bash
# Automatically runs before dev/build via predev/prebuild hooks
pnpm sync:env
```

The `scripts/sync-env.js` copies `.env.shared` → `apps/*/.env` and `packages/*/.env`. If `.env.shared` doesn't exist, it's created from `.env.shared.example`.

### Database Workflows

**Database must run via Docker first**:

```bash
docker-compose up -d  # Starts postgres on port 5432
```

**Migration workflow** (runs from `packages/database` directly to avoid Turbo interactive mode restrictions):

```bash
pnpm run db:migrate:dev     # Creates and applies migrations (runs: cd packages/database && pnpm run db:migrate:dev)
pnpm run db:push            # Push schema changes without migrations
pnpm run db:generate        # Regenerate Prisma Client
pnpm run db:seed            # Seed database
pnpm run db:studio          # Open Prisma Studio
```

**After schema changes**: Always run `pnpm run db:generate` to update `packages/database/generated/client/`.

### Build & Development

```bash
pnpm run dev      # Starts both FE (3001) and BE (3000) in watch mode
pnpm run build    # Builds all apps/packages in dependency order (turbo's ^build)
pnpm run start    # Starts production builds
```

**Important**: `predev` and `prebuild` hooks run `pnpm sync:env` and `turbo run predev/prebuild`, which triggers `db:generate` in the database package.

### Turbo Task Dependencies

Key tasks from `turbo.json`:

- `build` depends on `^build` (builds dependencies first)
- `dev` has `persistent: true` and `cache: false`
- Database tasks (`db:*`) have `cache: false` to prevent stale state
- `lint` and `test` depend on `^lint` and `^build` respectively

## Project-Specific Conventions

### Package Naming & Imports

All internal packages use `@repo/*` scope:

```typescript
// In apps/be
import { CreateUserDto, User } from '@repo/api';
import { PrismaService } from 'src/prisma/prisma.service';
import { PrismaClient } from '@repo/database/client';

// In apps/fe
import { User } from '@repo/api';
import { Button } from '@repo/ui';
```

### Prisma Integration Pattern

NestJS uses a custom `PrismaService` (in `apps/be/src/prisma/`) that:

- Extends `PrismaClient` from `@repo/database/client`
- Implements `OnModuleInit` to connect on app startup
- Logs all queries in development (via `$on('query')`)

### API Layer Structure

Each domain (users, links) follows this structure:

```
packages/api/src/
  users/
    dto/
      create-user.dto.ts
      update-user.dto.ts
    entities/
      user.entity.ts (implements Prisma User type)
```

All exports centralized in `packages/api/src/entry.ts` for clean imports.

**Entity Implementation Pattern**: Entities must implement the corresponding Prisma type:

```typescript
// packages/api/src/users/entities/user.entity.ts
import { User as PrismaUser } from '@repo/database/client';

export class User implements PrismaUser {
  id: number;
  email: string;
  name: string;
  emailVerified: Date | null;

  constructor(data: PrismaUser) {
    this.id = data.id;
    this.email = data.email;
    this.name = data.name;
    this.emailVerified = data.emailVerified;
  }
}
```

This ensures compile-time type safety when the Prisma schema changes.

### Frontend API Configuration

Frontend uses axios with baseURL from `apps/fe/src/config/axios.ts`:

- Development: `http://localhost:3000`
- Production: `process.env.NEXT_PUBLIC_SERVER_URL`

Backend enables CORS in `apps/be/src/main.ts` via `app.enableCors()`.

### Next.js Hybrid Data Fetching Pattern

**CRITICAL**: This project uses TWO data fetching approaches:

1. **Server Components + Prisma Direct Access** (for SSR):

```typescript
// apps/fe/app/page.tsx
import { prisma } from '@repo/database/client';

export default async function Home() {
  const users = await prisma.user.findMany(); // Direct DB access in RSC
}
```

2. **Client Components + REST API** (for client-side):

```typescript
// apps/fe/src/api/links/index.ts
import { api } from '@config/axios';
export async function getLinks() {
  const res = await api.get<Link[]>('/links'); // Backend API call
}
```

**When to use each**:

- Server Components: Use Prisma directly for initial page loads (no API roundtrip)
- Client Components: Use REST API for mutations and client-side data fetching
- Both share types from `@repo/api` for type safety

**Error Handling Pattern** (Client-side API calls):

```typescript
// apps/fe/src/api/links/index.ts
export async function getLinks(): Promise<Link[]> {
  try {
    const res = await api.get<Link[]>(`/links`);
    if (!res.data) {
      throw new Error('Failed to fetch links');
    }
    return res.data;
  } catch (error) {
    console.error('Error fetching links:', error);
    return []; // Return safe default instead of throwing
  }
}
```

Client-side API functions return safe defaults on error to prevent UI crashes.

### React Query Configuration

Next.js App Router uses a **server/client-aware QueryClient** pattern:

```typescript
// apps/fe/src/config/get-query-client.ts
export function getQueryClient() {
  if (isServer) {
    return makeQueryClient(); // New instance per request
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient; // Singleton for browser
  }
}
```

Default settings: `staleTime: 60000ms`, enables dehydration for pending queries.

### TypeScript Path Aliases

Frontend uses custom path aliases defined in `apps/fe/tsconfig.json`:

```typescript
import { getLinks } from '@/api/links'; // → src/api/links
import { api } from '@/config/axios'; // → src/config/axios
import Provider from '@/provider'; // → src/provider
```

**Note**: The alias is `@/*` mapping to `./src/*`, not `@api/*` or `@config/*`.

### NestJS Module Pattern

Each domain module imports `PrismaModule` for database access:

```typescript
// apps/be/src/users/users.module.ts
@Module({
  imports: [PrismaModule],  // Provides PrismaService
  controllers: [UsersController],
  providers: [UsersService],
})
```

Services inject `PrismaService` and use type-safe Prisma Client methods.

**Service Implementation Pattern**:

```typescript
// apps/be/src/users/users.service.ts
import { PrismaService } from '@/prisma/prisma.service';
import { CreateUserDto, UpdateUserDto } from '@repo/api';
import { User } from '@repo/database/client';

@Injectable()
export class UsersService {
  constructor(private readonly prisma: PrismaService) {}

  create(createUserDto: CreateUserDto): Promise<User> {
    return this.prisma.user.create({ data: createUserDto });
  }

  findAll(): Promise<User[]> {
    return this.prisma.user.findMany();
  }

  // ... other CRUD methods
}
```

**Important**: Use DTOs from `@repo/api` for input, return Prisma types from `@repo/database/client` for output.

### DTO Pattern with Mapped Types

DTOs use `@nestjs/mapped-types` for inheritance:

```typescript
// UpdateUserDto extends CreateUserDto with all fields optional
export class UpdateUserDto extends PartialType(CreateUserDto) {}
```

This pattern ensures Update DTOs stay in sync with Create DTOs automatically.

### Database Seeding Pattern

Seed files use `upsert` for idempotency:

```typescript
// packages/database/src/seed/user.ts
await prisma.user.upsert({
  where: { email: user.email },
  update: { ...user },
  create: { ...user },
});
```

Run multiple times safely without duplicates. Always disconnect after seeding.

## Common Tasks

### Adding a New Entity

1. Update `packages/database/prisma/schema.prisma`
2. Run `pnpm run db:migrate:dev` (creates migration + generates client)
3. Create DTOs in `packages/api/src/<entity>/dto/`
4. Create entity class implementing Prisma type in `packages/api/src/<entity>/entities/`
5. Export from `packages/api/src/entry.ts`
6. Create NestJS module/service/controller in `apps/be/src/<entity>/`
7. Inject `PrismaService` and use generated client methods

### Running Tests

```bash
pnpm run test           # Runs all tests via Turbo
# In specific app:
cd apps/be && pnpm run test:watch
```

### Linting & Formatting

```bash
pnpm run lint           # ESLint across all packages
pnpm run format         # Prettier format all files
```

Husky + lint-staged configured to auto-fix on commit (`.husky/pre-commit` runs `lint-staged`).

### Development Server Ports

- **Frontend**: http://localhost:3001 (Next.js with Turbopack)
- **Backend**: http://localhost:3000 (NestJS)
- **Database**: localhost:5432 (Postgres in Docker)
- **Prisma Studio**: http://localhost:5555 (when running `pnpm run db:studio`)

### Next.js Configuration Notes

- Uses Turbopack in dev mode (`--turbopack` flag)
- Configured with `force-dynamic` export for pages requiring fresh data
- `allowedDevOrigins` set to `http://localhost:3000` for backend integration

## Database Access

**Option 1**: Direct postgres access via Docker:

```bash
docker exec -it turborepo_postgres bash
psql -h localhost -p 5432 -U prisma -d postgres_db
```

**Option 2**: Prisma Studio (recommended):

```bash
pnpm run db:studio
```

## Tooling Versions

- Node: >=22.19.0
- pnpm: 10.15.1 (enforced via `packageManager` field)
- Prisma: 6.19.0
- Next.js: 15.x (using Turbopack)
- NestJS: 11.x
- React: 19.x

## Key Files to Reference

- `turbo.json` - Task orchestration and caching config
- `pnpm-workspace.yaml` - Workspace structure
- `scripts/sync-env.js` - Environment sync logic
- `packages/database/prisma/schema.prisma` - Database schema
- `apps/be/src/prisma/prisma.service.ts` - Prisma integration pattern
- `packages/api/src/entry.ts` - Shared API exports
